using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Rop.ProxyGenerator
{
    [Generator]
    public class ProxyGenerator : ISourceGenerator
    {
        private static readonly string[] _memberOverrideAtts=new string[]{"OverrideNoBase","OverrideNew","OverrideWithPreBase","OverrideWithPostBase"};
        private static readonly ImmutableHashSet<string> _memberOverrideAttsHash = _memberOverrideAtts.ToImmutableHashSet();

        public void Initialize(GeneratorInitializationContext context)
        {
//#if DEBUG
//            if (!Debugger.IsAttached)
//            {
//                Debugger.Launch();
//            }
//#endif
            context.RegisterForSyntaxNotifications(() => new ProxyClassesToAugmentReceiver());

        }
        
        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as ProxyClassesToAugmentReceiver;
            if (collector == null || collector.ClassesToAugment.Count == 0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
                generateCode(context, classtoaugment);
            }
            collector.Clear();
        }
        private void generateCode(GeneratorExecutionContext context, ProxyClassToAugment classtoaugment)
        {
            var file = classtoaugment.ClassToAugment.FileName +".Proxy_"+classtoaugment.InterfaceToProxy.InterfaceName.Name+".g.cs";
            var iname = classtoaugment.InterfaceToProxy.InterfaceName;
            var model = context.Compilation.GetSemanticModel(classtoaugment.ClassToAugment.Original.SyntaxTree);
            var classmodel = (INamedTypeSymbol)model.GetDeclaredSymbol(classtoaugment.ClassToAugment.Original);
            if (classmodel is null) return;
            var i = classmodel.AllInterfaces.FirstOrDefault(ii =>iname.Equals(ii));
            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for Proxy class");
            sb.AppendLines(classtoaugment.ClassToAugment.GetHeader(i));
            if (i== null) return;
            var symbols = i.GetOrderedMembers();
            foreach (var symbol in symbols)
            {
                var name = symbol.Name;
                if (classtoaugment.InterfaceToProxy.Excludes.Contains(name))
                {
                    sb.AppendLine();
                    sb.AppendLines(2,$"// Symbol '{name}' excluded");
                    sb.AppendLine();
                    continue;
                }

                switch (symbol)
                {
                    case IPropertySymbol propertySymbol:
                        augmentProperty(sb, propertySymbol,classtoaugment,i);
                        break;
                    case IMethodSymbol methodSymbol:
                        augmentMethod(sb, methodSymbol,classtoaugment,i);
                        break;
                    case IEventSymbol eventSymbol:
                        augmentEvent(sb, eventSymbol,classtoaugment,i);
                        break;
                }
            }
            sb.AppendLines(classtoaugment.ClassToAugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }
        private void augmentProperty(StringBuilder sb, IPropertySymbol prop,ProxyClassToAugment classToAugment,INamedTypeSymbol i)
        {
            var name = prop.Name;
            var tipo = prop.Type;
            var field = classToAugment.InterfaceToProxy.FieldName;
            var aoverride=prop.GetDecoratedWith(_memberOverrideAttsHash);
            var voro = GetOverrideString(aoverride);
            sb.Append($"\t\tpublic {voro} {tipo} {name}");
            sb.Append("{");
            if (!prop.IsWriteOnly) sb.Append($" get=>{field}.{name};");
            if (!prop.IsReadOnly) sb.Append($" set=>{field}.{name}=value;");
            sb.AppendLine("}");
        }

        private static string GetOverrideString(AttributeData aoverride)
        {
            return (aoverride == null) ? "virtual" : ((aoverride.GetShortName() == "OverrideNew") ? "new" : "override");
        }

        private void augmentEvent(StringBuilder sb, IEventSymbol prop,ProxyClassToAugment classToAugment,INamedTypeSymbol i)
        {
            var name = prop.Name;
            var tipo = prop.Type;
            var field = classToAugment.InterfaceToProxy.FieldName;
            sb.Append($"\t\tpublic event {tipo} {name}");
            sb.Append("{");
            sb.Append($" add=>{field}.{name}+=value;");
            sb.Append($" remove=>{field}.{name}-=value;");
            sb.AppendLine("}");
        }
        private void augmentMethod(StringBuilder sb, IMethodSymbol meth, ProxyClassToAugment classToAugment,INamedTypeSymbol i)
        {
            if (meth.MethodKind!=MethodKind.Ordinary) return;
            var name = meth.Name;
            var tipo = meth.ReturnType.ToString();
            var field = classToAugment.InterfaceToProxy.FieldName;
            var aoverride=meth.GetDecoratedWith(_memberOverrideAttsHash);
            var voro = GetOverrideString(aoverride);
            var prebase = aoverride.GetShortName() == "OverrideWithPreBase";
            var postbase = aoverride.GetShortName() == "OverrideWithPostBase";
            var pdef = string.Join(", ", meth.Parameters.Select(p =>$"{p.Type.ToString()} {p.MetadataName}"));
            var pnames= string.Join(", ", meth.Parameters.Select(p => p.MetadataName));
            var retstr = (tipo == "void") ? "" : "return ";

            sb.AppendLines(2,
                $"public {voro} {tipo} {name} ({pdef})",
                "{");
            if (prebase) 
                sb.AppendLines(3,
                    $"base.{name}({pnames});");
            if (!postbase)
                sb.AppendLines(3,
                    $"{retstr}{field}.{name} ({pnames});");
            else
                sb.AppendLines(3, 
                    $"{field}.{name} ({pnames});",
                    $"{retstr}{field}.{name} ({pnames});");
            sb.AppendLines(2,
                "}");
        }

        class ProxyClassesToAugmentReceiver : ISyntaxReceiver
        {
            public ConcurrentBag<ProxyClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<ProxyClassToAugment>();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                // Business logic to decide what we're interested in goes here
                if (syntaxNode is ClassDeclarationSyntax cds && cds.IsDecoratedWith("ProxyOf"))
                {
                    var ac = new ProxyClassToAugment(cds);
                    if (ac.InterfaceToProxy !=null) ClassesToAugment.Add(ac);
                }
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<ProxyClassToAugment>();
            }
        }
    }
}
