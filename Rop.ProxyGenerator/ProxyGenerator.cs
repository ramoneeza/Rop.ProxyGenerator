using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Rop.ProxyGenerator
{
    [Generator]
    public class ProxyGenerator : ISourceGenerator
    {


        public void Initialize(GeneratorInitializationContext context)
        {
            //#if DEBUG
            //            if (!Debugger.IsAttached)
            //            {
            //                Debugger.Launch();
            //            }
            //#endif 
            context.RegisterForSyntaxNotifications(() => new ProxyClassesToAugmentReceiver());

        }

        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as ProxyClassesToAugmentReceiver;
            if (collector == null || collector.ClassesToAugment.Count == 0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
                generateCode(context, classtoaugment);
            }
            collector.Clear();
        }
        private void generateCode(GeneratorExecutionContext context, ProxyClassToAugment classtoaugment)
        {
            var file = classtoaugment.ClassToAugment.FileName +".Proxy_"+classtoaugment.InterfaceToProxy.InterfaceName+".g.cs";
            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for Proxy class");
            sb.AppendLines(classtoaugment.ClassToAugment.GetHeader());
            var model = context.Compilation.GetSemanticModel(classtoaugment.ClassToAugment.Original.SyntaxTree);
            var classmodel = (INamedTypeSymbol)model.GetDeclaredSymbol(classtoaugment.ClassToAugment.Original);
            if (classmodel is null) return;
            var iname = classtoaugment.InterfaceToProxy.InterfaceName;
            var i = classmodel.AllInterfaces.FirstOrDefault(ii => ii.Name == iname);
            if (i== null) return;
            var morder = i.MemberNames.ToArray();
            var mn = morder.ToImmutableHashSet();
            var m = i.GetMembers().Where(mm=>mn.Contains(mm.Name)).ToDictionary(s=>s.Name);
            foreach (var name in morder)
            {
                var symbol = m[name];
                switch (symbol)
                {
                    case IPropertySymbol propertySymbol:
                        augmentProperty(sb, propertySymbol,classtoaugment);
                        break;
                    case IMethodSymbol methodSymbol:
                        augmentMethod(sb, methodSymbol,classtoaugment);
                        break;
                    case IEventSymbol eventSymbol:
                        augmentEvent(sb, eventSymbol,classtoaugment);
                        break;
                }
            }
            sb.AppendLines(classtoaugment.ClassToAugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }

        private void augmentProperty(StringBuilder sb, IPropertySymbol prop,ProxyClassToAugment classToAugment)
        {
            var name = prop.Name;
            var tipo = prop.Type;
            var field = classToAugment.InterfaceToProxy.FieldName;
            sb.Append($"\t\tpublic virtual {tipo} {name}");
            sb.Append("{");
            if (!prop.IsWriteOnly)
            {
                sb.Append($" get=>{field}.{name};");
            }
            if (!prop.IsReadOnly)
            {
                sb.Append($" set=>{field}.{name}=value;");
            }
            sb.AppendLine("}");

        }
        private void augmentEvent(StringBuilder sb, IEventSymbol prop,ProxyClassToAugment classToAugment)
        {
            var name = prop.Name;
            var tipo = prop.Type;
            var field = classToAugment.InterfaceToProxy.FieldName;
            sb.Append($"\t\tpublic event {tipo} {name}");
            sb.Append("{");
            sb.Append($" add=>{field}.{name}+=value;");
            sb.Append($" remove=>{field}.{name}-=value;");
            sb.AppendLine("}");
        }
        private void augmentMethod(StringBuilder sb, IMethodSymbol meth, ProxyClassToAugment classToAugment)
        {
            if (meth.MethodKind!=MethodKind.Ordinary) return;
            
            var name = meth.Name;
            var tipo = meth.ReturnType.ToString();
            var field = classToAugment.InterfaceToProxy.FieldName;
            sb.Append($"\t\tpublic virtual {tipo} {name}");
            sb.Append("(");
            var pdef = string.Join(", ", meth.Parameters.Select(p =>$"{p.Type.ToString()} {p.MetadataName}"));
            sb.Append(pdef);
            sb.AppendLine(")");
            sb.AppendLine("\t\t{");
            sb.Append("\t\t\t");
            if (tipo!="void") sb.Append("return ");
            sb.Append($"{field}.{name}");
            sb.Append("(");
            var pnames= string.Join(", ", meth.Parameters.Select(p => p.MetadataName));
            sb.Append(pnames);
            sb.AppendLine(");");
            sb.AppendLine("\t\t}");
        }

        class ProxyClassesToAugmentReceiver : ISyntaxReceiver
        {
            public ConcurrentBag<ProxyClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<ProxyClassToAugment>();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                // Business logic to decide what we're interested in goes here
                if (syntaxNode is ClassDeclarationSyntax cds && cds.IsDecoratedWith("ProxyOf"))
                {
                    var ac = new ProxyClassToAugment(cds);
                    if (ac.InterfaceToProxy !=null) ClassesToAugment.Add(ac);
                }
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<ProxyClassToAugment>();
            }
        }
    }
}
